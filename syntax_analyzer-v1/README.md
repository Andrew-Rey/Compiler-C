# Syntax Parser on miniC

## 说一下每个文件夹

demo: 放一些测试案例, 目前加了三个, 如果要更改目录, 自行修改 CMakeLists

header: 头文件

- LexicalAnalyzer: 词法分析程序, 基本和之前提交的一样, 主要增加了一些运算符的判断, 把控制台的输出重定向到全局变量 `symbol_table` 去了
- SyntaxParser: 语法分析程序, 实现 `LR(1)` 语法分析程序, 细节后面讲
- 包含了其他的供给全部文件的头文件

output: 输出文件, 包含了AST语法树, `LR(1)` 闭包, `LR(1)` 分析表. (如果没有可以根据**主函数**里的提示自己生成)

src: 一如既往的没啥用

## 说一下语法分析

~~后续应该会提交报告 (?)~~

包含两大内容: 一个是全局可使用的头文件, 一个是语法分析的专用头文件

### 全局

Alphabet.h: 顾名思义, 字母表, 包含了**终结符, 非终结符, 保留字**三大类, 内部定义了**判断是否是终结符的函数** `isTerminal()`, **判断是否是空串的函数** `isEps()` 和 **获取字母表大小的函数** `tokenCount()`

Production.h: 定义了产生式, 可以添加或修改产生式, 不过要记得同时**检查字母表**相应位置是否要修改, 比如**宏定义**啥的, 定义了一些与产生式相关的比较实用的函数: 例如**寻找左侧为xx的所有产生式**, **寻找某个闭包里面正在读取xx的所有产生式**

Global.h: 可以说是该项目之祖宗了. 基本就是定义了所有让人~~眼前一黑~~耳目一新的数据类型和各种宏 (甚至还有控制输出格式的), 然后定义全局变量 `symbol_table`, `lr1_table`, `producitons`, `first_set`. 还顺便定义了很多短小精悍的函数

### 语法分析

三大内容: 生成 `LR(1)` 分析表, 对 `symbol_table` 进行语法分析, 生成 `AST`

#### 生成 `LR(1)` 分析表

...真难写, 真难debug

基本就用了最为朴实的方法: 先生成闭包, 然后填表; 生成闭包的时候又是按部就班地先生成每个符号的First集, 然后由开始符号开始, 逐步迭代求解.

刚开始是使用每一次递归都全部遍历一遍, 后来发现第一是状态实在太多了, 每个状态里面包含的产生式也很多, 所以后来改为只遍历新出现的状态, 快一丢丢. (重新生成`LR(1)`分析表的Release时间大概为**两三分钟**, 一定不是死循环)

在**处理移进-规约冲突**的时候, 使用了最简单的先移进的策略 ~~(昂就一行代码)~~

#### 对 `symbol_table` 进行语法分析

没想到这个还挺好写的, 数据类型先是用 `Token` 进行的测试, 通过后转为了 `AstNode`, 便于输出 `AST`

#### 生成 `AST`

可以简单可以复杂吧, 反正我觉得生成的 `AST` 挺丑的.